import { createLogger } from '@/lib/security/logger';

const log = createLogger('security-malware-scanner');

/**
 * Malware Scanner
 *
 * SEC-013: Scans uploaded files for malware using VirusTotal API v3.
 *
 * Strategy:
 * 1. Compute SHA-256 hash of uploaded file
 * 2. Check VirusTotal by hash (free, no upload needed if file is known)
 * 3. If unknown, upload to VirusTotal for scanning
 * 4. Block file if any engine detects malware
 *
 * Falls back to extension/MIME validation if VirusTotal is unavailable.
 */

const VIRUSTOTAL_API_URL = 'https://www.virustotal.com/api/v3';

export interface ScanResult {
  safe: boolean;
  scanned: boolean;
  detections: number;
  totalEngines: number;
  threatName: string | null;
  hash: string;
  error?: string;
}

/**
 * Compute SHA-256 hash of a file buffer.
 */
async function computeSHA256(buffer: ArrayBuffer): Promise<string> {
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Check a file hash against VirusTotal.
 * Returns scan results if the file is known, null if unknown.
 */
async function checkHash(
  hash: string,
  apiKey: string
): Promise<ScanResult | null> {
  try {
    const response = await fetch(`${VIRUSTOTAL_API_URL}/files/${hash}`, {
      headers: { 'x-apikey': apiKey },
    });

    if (response.status === 404) {
      return null; // File not known to VirusTotal
    }

    if (!response.ok) {
      log.error(`[malware-scanner] VirusTotal hash check failed: ${response.status}`);
      return null;
    }

    const data = await response.json();
    const stats = data.data?.attributes?.last_analysis_stats;

    if (!stats) return null;

    const detections = (stats.malicious || 0) + (stats.suspicious || 0);
    const totalEngines = Object.values(stats).reduce(
      (sum: number, val) => sum + (typeof val === 'number' ? val : 0),
      0
    );

    // Extract threat name from first detection
    let threatName: string | null = null;
    if (detections > 0 && data.data?.attributes?.last_analysis_results) {
      const results = data.data.attributes.last_analysis_results;
      for (const engine of Object.values(results)) {
        const result = engine as { category: string; result: string | null };
        if (result.category === 'malicious' && result.result) {
          threatName = result.result;
          break;
        }
      }
    }

    return {
      safe: detections === 0,
      scanned: true,
      detections,
      totalEngines,
      threatName,
      hash,
    };
  } catch (err) {
    log.error('[malware-scanner] VirusTotal hash check error:', err);
    return null;
  }
}

/**
 * Upload a file to VirusTotal for scanning.
 * Note: This is asynchronous — VirusTotal may take minutes to complete.
 * For immediate results, we poll once after a short delay.
 */
async function uploadAndScan(
  buffer: ArrayBuffer,
  fileName: string,
  hash: string,
  apiKey: string
): Promise<ScanResult> {
  try {
    const formData = new FormData();
    formData.append('file', new Blob([buffer]), fileName);

    const uploadResponse = await fetch(`${VIRUSTOTAL_API_URL}/files`, {
      method: 'POST',
      headers: { 'x-apikey': apiKey },
      body: formData,
    });

    if (!uploadResponse.ok) {
      return {
        safe: true,
        scanned: false,
        detections: 0,
        totalEngines: 0,
        threatName: null,
        hash,
        error: `VirusTotal upload failed: ${uploadResponse.status}`,
      };
    }

    // VirusTotal returns an analysis ID; we could poll for results,
    // but for UX we allow the upload and check the hash later.
    // The next upload of the same file will have results cached.
    return {
      safe: true,
      scanned: false,
      detections: 0,
      totalEngines: 0,
      threatName: null,
      hash,
      error: 'File submitted for scanning — results pending',
    };
  } catch (err) {
    return {
      safe: true,
      scanned: false,
      detections: 0,
      totalEngines: 0,
      threatName: null,
      hash,
      error: err instanceof Error ? err.message : 'Upload scan failed',
    };
  }
}

/**
 * Scan a file for malware.
 *
 * @param buffer - The file contents as ArrayBuffer
 * @param fileName - Original filename (for upload)
 * @returns ScanResult indicating if the file is safe
 */
export async function scanFile(
  buffer: ArrayBuffer,
  fileName: string
): Promise<ScanResult> {
  const apiKey = process.env.VIRUSTOTAL_API_KEY;
  const hash = await computeSHA256(buffer);

  // If no API key, fall back to safe (extension/MIME already validated in upload route)
  if (!apiKey) {
    return {
      safe: true,
      scanned: false,
      detections: 0,
      totalEngines: 0,
      threatName: null,
      hash,
      error: 'VirusTotal API key not configured — skipping malware scan',
    };
  }

  // Step 1: Check hash (instant, no quota cost if file is known)
  const hashResult = await checkHash(hash, apiKey);

  if (hashResult) {
    if (!hashResult.safe) {
      log.error(
        `[malware-scanner] MALWARE DETECTED in "${fileName}": ` +
        `${hashResult.detections}/${hashResult.totalEngines} engines, ` +
        `threat: ${hashResult.threatName}`
      );
    }
    return hashResult;
  }

  // Step 2: File unknown — upload for scanning
  return uploadAndScan(buffer, fileName, hash, apiKey);
}

/**
 * Check if a previously uploaded file has scan results available.
 * Use this for deferred scanning (check results after upload).
 */
export async function checkFileStatus(hash: string): Promise<ScanResult | null> {
  const apiKey = process.env.VIRUSTOTAL_API_KEY;
  if (!apiKey) return null;

  return checkHash(hash, apiKey);
}
